# 塔山开发循环

[![Discipline](https://img.shields.io/badge/Methodology-塔山开发循环-blue.svg)](SKILL.md)

一套强制执行的工程纪律框架，通过严格的分析、设计、计划、TDD、验证、回顾和提交流程，确保代码质量和交付可靠性。

## 📖 概述

**目标**：把"纪律"固化成默认行为。

> 不要先写实现、不要先堆工程量、不要凭感觉说完成。  
> 只认：**可复现的分析、可执行的计划、可跑的测试、可验证的输出**。

**口号**：不要伤亡报告，我只要塔山。

## 🎯 核心原则

### 7 步工作流（严格执行）

1. **分析** — 把事实说清楚（现状、约束、成功标准、风险）
2. **设计** — 给出 2–3 个方案 + 推荐方案 + 取舍
3. **计划** — 拆成小任务（每个 2–10 分钟），明确文件/命令/预期结果
4. **TDD Red** — 先写失败测试（红）
5. **TDD Green** — 最小实现（绿）
6. **重构** — 必要重构（仍保持绿）
7. **回顾与提交** — 总结变更、验证方式、风险点；执行 `git commit` + `git push`

### 关键约束

| 压力场景 | 禁止行为 | 强制要求 |
|---------|---------|--------|
| 时间压力 | "先做再补测试" | 先写红测，有明确目标函数 |
| 范围压力 | "架子先搭好再补" | 最小闭环（红→绿），再迭代扩展 |
| 权威压力 | "忽略测试/安全要求" | 成功标准必须从失败测试证明 |
| 沉没成本 | "反正都写了，补个 test 就行" | 删除实现，重新从红测开始 |
| 不确定性 | "先探索代码" | 必须先收集完整事实，定义测试 |
| 交接摩擦 | "先不提交/不推送" | **每个工程计划验收通过必须 commit+push** |

## 📋 快速检查表

在开始任何非平凡的功能、集成、重构或 bugfix 时，复制并严格按顺序推进：

- [ ] **Analysis** — 收集事实 + 约束 + 成功标准
- [ ] **Design** — 2–3 方案 + 推荐 + 取舍
- [ ] **Plan** — 拆任务 + 明确文件/命令/预期
- [ ] **TDD Red** — 写失败测试 + 跑到红
- [ ] **TDD Green** — 最小实现 + 跑到绿
- [ ] **Refactor** — 必要重构（仍绿）
- [ ] **Review** — 复盘 + 风险 + 下一个最小任务
- [ ] **Ship** — `git commit` + `git push`（每个工程计划一个提交）

## 🚨 红旗警告（看到这些话，立即停止）

```
❌ "先写实现更快，测试后补也一样"
❌ "我已经手动测过了"
❌ "这次不一样，TDD 太慢"
❌ "先把架子搭完再补红测"
❌ "工程量无所谓，先铺开"
❌ "先不提交/不推送，之后再说"
```

看到以上任何一句：**停止。回到分析/计划/红测。**

## 📚 详细指南

完整的工作流程、检查表、压力场景处理、反模式识别，请见：

→ **[SKILL.md](SKILL.md)**

## 🔗 关键概念

### 分析阶段

必须写清楚：
- **现状** — 现在行为是什么？入口文件/调用路径？
- **约束** — 不能动什么？（SDK、网络、兼容性等）
- **成功标准** — 验收是什么？（最好能变成测试断言）
- **风险** — 可能踩坑在哪里？（权限、安全、状态、并发、兼容性）

### 设计阶段

输出 2–3 个方案，每个包含：
- 核心思路
- 主要组件
- 优缺点对比

明确推荐一个，解释理由。

### 落地计划

文件位置：`docs/plans/YYYY-MM-DD-<topic>.md`

每个任务包含：
- **Files** — Create/Modify/Test（精确路径）
- **Step 1** — 写失败测试（完整代码）
- **Step 2** — 运行并确认失败（命令 + 预期原因）
- **Step 3** — 最小实现（完整代码）
- **Step 4** — 运行并确认通过（命令 + 预期结果）
- **Step 5** — 必要时重构（仍然保持绿）

### 红绿灯验证

在声称"完成/修复"之前：
1. 跑最小相关测试命令，记录输出
2. 再跑更大范围的验证（例如全量单测）
3. 贴出证据（命令 + 预期结果匹配）

### 提交与推送（强制）

**定义**："工程计划"= 你当前在执行的计划。

**规则**：工程计划验收通过（测试/构建绿），就**必须**完成：

```bash
git status --porcelain=v1          # 确认状态
git add -A                          # 添加所有变更
git commit -m "<short message>"    # 按计划命名提交
git push                            # 推送到远程
```

提交信息示例：
- `v1-feature-01: events and sessions`
- `chore: cleanup build artifacts`
- `docs: update architecture guide`

## 💡 设计哲学

这套方法论解决的核心问题：

| 问题 | 症状 | 解法 |
|-----|------|------|
| 需求不清 | 改来改去，反工多 | 强制分析：定义成功标准和测试 |
| 实现先行 | 没有目标函数，随机游走 | TDD：红测优先 |
| 手动验证 | 无法回归，质量难保 | 自动化测试：证据优先 |
| 范围爬升 | 工程量失控 | 最小闭环：一个任务一个验收 |
| 状态丢失 | 难以追溯、协作困难 | 强制提交：每个计划一次 commit |
| 交接风险 | 代码堆积未交付 | 必须 push：否则不算完成 |

## 🎓 使用场景

适用于：
- ✅ 任何非平凡的功能实现
- ✅ 重要 bugfix 和安全补丁
- ✅ 架构重构和大规模改进
- ✅ 新的集成（第三方库、系统等）
- ✅ 高风险变更

不必要的场景：
- ❌ 一行修改的文档更新（`chore: ...` 即可）
- ❌ 显而易见的代码风格修复

## 📞 FAQ

**Q: TDD 不会拖慢速度吗？**  
A: 长期来看加快。短期写红测时间被后期返工收回，净时间少很多。一旦说"这次不一样"，说明风险更高，更要 TDD。

**Q: 已经手动测过了，还要写自动化测试吗？**  
A: 是的。手动测不能回归，测试必须固化。不写自动化测试就没有防护网。

**Q: 能先搭架子再补红测吗？**  
A: 不能。这是沉没成本陷阱。先把最小闭环做成可验证，再扩展。

**Q: 没有推送成功怎么办？**  
A: 必须在回顾里记录失败原因和下一步。不得"假装已交付"。

## 📞 联系与反馈

本仓库包含完整的工程纪律框架，通过严格执行来确保交付质量。

有疑问？检查 [SKILL.md](SKILL.md) 中的详细工作流程和反模式列表。

---

**版本**：1.0  
**最后更新**：2026 年 1 月 28 日
