---
name: tashan-development-loop
description: Use when driving an engineering project from a clear vision through iterative, versioned execution plans and milestones (doc/plan/vN-*), executing those plans with the Tashan development loop, reviewing gaps between outcomes and vision, and repeating with v(N+1) plans until the vision is fully delivered.
---

# 塔山项目循环（愿景 → 分解计划 → 里程碑 → 执行 → 回顾差异 → 新版本计划…直到收敛）

## Overview

塔山项目循环的目标不是“写代码”，而是让项目从愿景出发，经过可执行的计划与里程碑，进入可验证的开发闭环；每一轮交付都要回顾“实现与愿景的差异”，并形成下一版本计划，循环往复，直至愿景与实现之间无差异、无保留、无妥协为止。

其中，“塔山开发循环”只是**执行计划**的那一部分。

## Quick Reference

1) **建立愿景**（若已存在可再次读一遍并适当更新/不存在则以头脑风暴的方式、以产品经理的视角与用户共建一份产品的愿景）：把“最终要达成什么”写成可验收的文字/指标/行为定义。
2) **分解执行计划**：在 `docs/plan/` 下写作一组版本化计划文件 `vN-*`，把愿景拆成可交付 slice（每个都有验收与验证命令/测试）。
3) **建立里程碑**：在 `vN-index` 中定义里程碑与交付清单（每个里程碑的 DoD/验证命令）。
4) **执行计划**：对每个计划条目使用“塔山开发循环”（红→绿→重构，证据优先）。
5) **回顾差异**：对照愿景，评估当前实现还差什么（范围、行为、性能、可靠性、可维护性、体验等），把差异写清楚。
6) **形成新版本计划**：把差异转成下一轮 `v(N+1)-*` 计划与 `v(N+1)-index`，并给出新的里程碑。
7) **提交与推送**：每一轮计划文档与对应实现收敛成一个可回溯状态后，进行 `git commit` 与 `git push`。
8) **重复执行**: 若第5步识别出较大差异，则继续重复执行以上过程，直至项目现实与愿景之间的差异收敛

## 文档与命名约定（doc/plan）

每一轮计划用一个版本号 `vN`（`N` 从 1 开始）：

- `docs/plan/v1-index.md`：总论与索引（愿景链接/摘要、里程碑表、交付清单、当前状态、已知差异）。
- `docs/plan/v1-<topic>.md`：单项计划（一个 slice / 一个主题 / 一个里程碑子项）。
- 下一轮迭代：`docs/plan/v2-index.md`、`docs/plan/v2-<topic>.md`……以此类推。

建议把 `vN-index` 当作“该版本的事实面板”，至少包含：

- 愿景：链接到愿景文档/PRD/需求说明（或直接写在 index 里）。
- 里程碑：名称、范围、DoD、验证命令/测试、状态（todo/doing/done）。
- 计划索引：链接到所有 `vN-<topic>.md`。
- 差异列表：本轮结束后仍未达成的差异（用于生成 v(N+1)）。

## 计划文件模板（vN-<topic>.md）

每个计划必须可执行、可验收、可验证，至少包含：

- **Goal**：这一项完成后，愿景的哪个部分被满足？
- **Scope**：做什么/不做什么（边界写清楚）。
- **Acceptance**：验收标准（尽量能转成测试断言或可重复验证命令）。
- **Files**：会创建/修改/测试哪些路径（精确到文件）。
- **Steps**（严格按顺序）：
  1) 写失败测试（红）
  2) 运行到红（给命令 + 预期失败原因）
  3) 最小实现（绿）
  4) 运行到绿（给命令 + 预期通过）
  5) 必要重构（仍绿）
- **Risks**：本计划的主要风险与缓解方式。

## 执行计划：塔山开发循环（Strict）

目标：把“纪律”固化成默认行为。不要先写实现、不要先堆工程量、不要凭感觉说完成。只认：可复现的分析、可执行的计划、可跑的测试、可验证的输出。

### Checklist（Copy/Paste）

把下面每一项都写进 `update_plan`，并严格按顺序推进（一次只做一个 in_progress）：

1) Analysis: 收集事实 + 约束 + 成功标准
2) Design: 2–3 方案 + 推荐 + 取舍（如果已经由计划明确锁定方案，可写“引用 vN-xxx 的方案选择”）
3) Plan: 拆任务 + 明确文件/命令/预期
4) TDD Red: 写失败测试 + 跑到红
5) TDD Green: 最小实现 + 跑到绿
6) Refactor: 必要重构（仍绿）
7) Review: 复盘 + 风险 + 下一个最小任务
8) Ship: `git commit` + `git push`（按版本/里程碑组织提交信息）

### 红绿灯（证据优先）

在声称“完成/修复/通过”之前：

- 跑最小相关测试命令（或验证命令），以输出为证据
- 再跑更大范围的验证（按里程碑执行）

## 回顾差异（愿景 vs. 现实）

回顾的产物不是“总结”，而是“差异清单”：

- 哪些愿景点已满足（证据：测试/命令/链接/截图/日志）
- 哪些仍未满足（差异：缺什么、为什么缺、影响是什么、是否进入下一轮）
- 哪些是本轮新增发现（需求澄清/约束变化/真实用户反馈）

把差异写进本轮 `vN-index`，并把每条差异落到下一轮 `v(N+1)-<topic>` 的可执行计划中。

## 提交与推送（强制）

当一轮 `vN` 的计划文档与对应实现达到“可回溯、可复现”的状态后，必须提交并推送：

- `git status --porcelain=v1`
- `git add -A`
- `git commit -m "vN: <short message>"`
- `git push`

如果推送失败（网络/权限/远程未配置），必须在 `vN-index` 的回顾区明确记录失败原因与下一步；不得“假装已交付”。

## Pressure Scenarios（常见跳步诱因）

1) **时间压力**：“先做出来再补测试/文档。”
2) **范围压力**：“工程量无所谓，先把大架子都搭好。”
3) **权威压力**：“别管愿景/里程碑，先写实现。”
4) **沉没成本**：“都写了这么多了，别改计划，补补就行。”
5) **不确定性压力**：“愿景还没定，先写点代码探索。”
6) **交接/摩擦压力**：“这次先不提交/不推送，之后再说。”

## Red Flags — STOP and Start Over

- “愿景先放一边，先把功能做了再说”
- “计划写不写都一样，反正我知道要做什么”
- “先写实现更快，测试后补也一样”
- “我已经手动测过了”
- “这次不一样，TDD 太慢”
- “先把架子搭完再补红测”
- “反正工程量不是问题，先铺开”
- “先不提交/不推送，之后再说”

## Rationalization Table (Close the Loops)

| 常见自我说服 | 反制语句（强制执行） |
|---|---|
| “先写实现更快，测试后补” | 先写红测；否则没有目标函数，只有随机游走。 |
| “我已经手动测过了” | 手动不是回归；必须把成功标准固化成测试。 |
| “这次不一样，TDD 太慢” | 一旦说“这次不一样”，说明风险更高，更要 TDD。 |
| “先把架子搭完再补红测” | 这是沉没成本陷阱；先做最小闭环（红→绿），再扩展。 |
| “工程量无所谓，先铺开” | 铺开会放大返工；先把最小 slice 做成可验证闭环。 |
| “提交/推送太麻烦，用户自己来” | 这是交接风险：**每个工程计划完成都必须 commit+push**，否则不算交付。 |


## Red Flags — STOP and Start Over

- “先写实现更快，测试后补也一样”
- “我已经手动测过了”
- “这次不一样，TDD 太慢”
- “先把架子搭完再补红测”
- “反正工程量不是问题，先铺开”
- “先不提交/不推送，之后再说”

看到以上任何一句：**停止。回到分析/计划/红测。**

## Anti-Patterns

- 写“宏大目标”但没有可执行步骤/命令/预期输出
- 把测试当成验收报告（测试必须先于实现）
- 用“看起来没问题”替代验证命令
- 完成工程计划但不提交/不推送，导致状态不可追溯